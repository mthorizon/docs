---
title: Sequence Wallet Linking Integration - Embedded Wallet Authentication & External Wallet Sign-in
description: This guide demonstrates how to integrate an Embedded Wallet with traditional authentication methods. It covers creating a verifiable link to sign into an external wallet, storing the session securely, and verifying the authentication.
---

import { Callout } from "vocs/components";

# Wallet Linking Integration Guide

**Time to complete: 20-30 minutes**

In this guide, we will showcase how to sign into an [Embedded Wallet](/solutions/wallets/embedded-wallet/overview) using traditional web2 authentication like email or social login. Then, a verifiable link is generated from the session which redirects a user to separate application that verifies the embedded wallet session and enables a user to sign into an external wallet via [Sequence Kit](/solutions/wallets/sequence-kit/overview).

This feature is very useful for when users are being onboarded with Embedded Wallets, with prior history and assets in external wallets. This architecture enables read-access of multiple linked wallets to perform querying of inventory, leaving assets in respective wallets untouched as well as enhancing the ability from liquidity or funds to flow from external wallets to wallets associated with a game.

<Callout type="info">
 The full boilerplate code can be found in the respective repositories if you would like to start integration right away:
  - [WaaS Auth Initiator Boilerplate](https://github.com/0xsequence-demos/demo-waas-wallet-link-initiator) - Logic associated with the embedded wallet for generating a verifiable link.
  - [WaaS Wallet Link Boilerplate](https://github.com/0xsequence-demos/demo-waas-wallet-link) - Application user is redirected to link their external account and view assets in their wallets.
  - The end to end example can be tested from this [Wallet Linking Demo](https://demo-waas-wallet-link-initiator.pages.dev/) by signing in and clicking the `Open Auth URL` button.
</Callout>

The Sequence tools in this guide will enable you to perform:

1. [Sequence Builder Console Signup & Project Creation](/solutions/wallets/link-wallets/integration-guide#1-sequence-builder-console-signup--project-creation): Create a project with the Sequence Builder
2. [Access Key Management](/solutions/wallets/link-wallets/integration-guide#2-access-key-management): Obtain a public access key, and WaaS config key to interact with the Sequence stack
3. [Embedded Wallet Integration](/solutions/wallets/link-wallets/integration-guide#3-embedded-wallet-integration): Integrate an Embedded Wallet into the application
4. [Nonce Generation](/solutions/wallets/link-wallets/integration-guide#4-nonce-generation): Generate and store a unique nonce
5. [Embedded Wallet Signature](/solutions/wallets/link-wallets/integration-guide#5-embedded-wallet-signature): Generate a signature to be used to verify with 
6. [Sequence Kit Sign In Wallet Linking Dapp](/solutions/wallets/link-wallets/integration-guide#6-sequence-kit-sign-in-dapp): Use Sequence Kit to sign a user in with their EOA wallet
7. [Embedded Wallet Session Wallet Verification](/solutions/wallets/link-wallets/integration-guide#7-embedded-wallet-session-wallet-verification): Verify a signature and session with the Sequence API to check the validity of an authenticated user session 
8. [(Optional) Query Balances in Singular Interface](/solutions/wallets/link-wallets/integration-guide#8-query-balances-in-singular-interface): Use the Sequence Indexer to query multiple wallets to aggregate tokens into a singular interface

## Wallet Linking Diagram Flow

![wallet linking guide sequence diagram](/img/guides/wallet-linking/wallet_linking_diagram.png)

## 1. Sequence Builder Console Signup & Project Creation

First start by following [this walkthrough](/support/builder/project-management) for how to sign up to the [Sequence Builder](https://sequence.build/) and to learn how to create a project.

## 2. Access Key Management

Now that you have a project, you'll need to acquire 2 different Access Keys for your project in order to authenticate your application with the Sequence Stack:
1. `Waas Config Key` used for the Embedded Wallet, which can be learned about [here](/solutions/builder/embedded-wallet).
2. `Project Access Key` used for the Embedded Wallet, Sequence Kit, & Sequence Indexer, which can be done [here](/solutions/builder/getting-started#claim-an-api-access-key).

<Callout type="info">
For this guide, while you're configuring your Embedded Wallet, in order to generate signatures a Parent Wallet will have to be deployed. You can learn about this [here](/solutions/wallets/embedded-wallet/examples/verification#prerequisite-deployment-of-a-parent-wallet).
</Callout>

## 3. Embedded Wallet Integration

<Callout type="info">
You can view and clone the template repository [here](https://github.com/0xsequence-demos/template-embedded-wallet-web2-auth) for the Embedded Wallet sign in
</Callout>

We'll start from scratch building up the project with the necessary pieces, to enable the use of a Sequence Embedded Wallet so users are onboarded to your application using web2 authentication providers.

First start by creating a project folder with `mkdir <project>`, then `cd <project>` and create a `vite` project using React:

```shell
pnpm create vite

# or 
yarn create vite

# or 
npm create vite
```

Next, we'll install the Wallet-as-a-Service (Waas) package to use the Embedded Wallet:

```shell
pnpm install @0xsequence/waas

# or
npm install @0xsequence/waas

# or
yarn add @0xsequence/waas
```

For all of the new files created in the follows steps, have them be created in `/src`

First, create a file called something like `SequenceEmbeddedWallet.ts` with the following initialization code:

```typescript
import { SequenceWaaS } from '@0xsequence/waas'

const sequence = new SequenceWaaS({
    projectAccessKey: import.meta.env.VITE_PROJECT_ACCESS_KEY!,
    waasConfigKey:  import.meta.env.VITE_WAAS_CONFIG_KEY!,
    network: 'arbitrum-nova'
})

export default sequence;
```

Then create another file called `useSessionHash.ts` that generates a session hash from the SDK unique to the user, which can be imported and used as a React hook:

```typescript
import sequence from './SequenceEmbeddedWallet.ts'
import { useEffect, useState } from "react";

export function useSessionHash() {
    const [sessionHash, setSessionHash] = useState("")
    const [error, setError] = useState<any>(undefined)

    useEffect(() => {
        const handler = async () => {
            try {
                setSessionHash(await sequence.getSessionHash())
            } catch (error) {
                console.error(error)
                setError(error)
            }
        }
        handler()
        return sequence.onSessionStateChanged(handler)
    }, [setSessionHash, setError])

    return {
        sessionHash,
        error,
        loading: !!sessionHash,
    }
}
```

Finally, to implement Google auth, you will need the `GoogleOAuthProvider`. The following command will install the provider as well as the Apple Auth sign in, which will be used later:

```shell
pnpm i @react-oauth/google react-apple-signin-auth
```

<Callout type="warning">
Apple authentication can not be used with localhost applications, so to test you'll need to deploy your application and update the `Allowed Origins` for the bundle id.
</Callout>

Then, the starter code is implemented with the previous imported files, in the following code within the `main.tsx` file, where the `GoogleOAuthProvider` wraps the application, where the `GOOGLE_CLIENT_ID` is obtained from the Google Developer Console. More on this [here](/solutions/builder/embedded-wallet/google-configuration):

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import App from './App.tsx'
import { useSessionHash } from "./useSessionHash.ts";

import { GoogleOAuthProvider } from '@react-oauth/google'


function Dapp() {
  const { sessionHash } = useSessionHash()

  return (
	<GoogleOAuthProvider clientId="<GOOGLE_CLIENT_ID>" nonce={sessionHash} key={sessionHash}>
		<App />
	</GoogleOAuthProvider>
  );
}

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <Dapp />
  </React.StrictMode>
)
```

Once your `main.tsx` is ready, lets create the login buttons, which will look like this:

![embedded wallet social login](/img/guides/treasure-chest/guide_treasure_chest_embedded_wallet_template.png)

In `App.tsx` use the following code that checks to see if a user is connected and presents a wallet address based on the signed in user, with the various social auth buttons and handlers:

```typescript
import { useState, useEffect } from 'react'
import './App.css'
import sequence from './SequenceEmbeddedWallet'
import { useSessionHash } from './useSessionHash'
import { CredentialResponse, GoogleLogin } from '@react-oauth/google';
import AppleSignin from 'react-apple-signin-auth';

function LoginScreen () {
  const { sessionHash } = useSessionHash()

  const [wallet, setWallet] = useState<any>(null)

  const handleGoogleLogin = async (tokenResponse: CredentialResponse) => {
    const res = await sequence.signIn({
      idToken: tokenResponse.credential! // inputted id credential from google
    }, "template")
    setWallet(res.wallet)
  }

  const handleAppleLogin = async (response: any) => {
    const res = await sequence.signIn({
      idToken: response.authorization.id_token! // inputted id token from apple
    }, "template")
 
    setWallet(res.wallet)
  }

  // checks to see if there is a logged in user
  useEffect(() => {
    setTimeout(async () => {
      if(await sequence.isSignedIn()){
        setWallet(await sequence.getAddress())
      }
    }, 0)
  }, [])

  useEffect(() => {

  }, [wallet])

  const signOut = async () => {
    try {
      const sessions = await sequence.listSessions()

      for(let i = 0; i < sessions.length; i++){
        await sequence.dropSession({ sessionId: sessions[i].id })
      }
    }catch(err){
      console.log(err)
    }
  }

  return (
    <>
      {
        !wallet 
      ? 
        <>
          <span className='sign-in-via'>SIGN IN VIA</span>
          <br/>
          <br/>
          <br/>
          <div className="login-container">
          <div className='dashed-box-google'>
              <p className='content'>
                <div className='gmail-login' style={{overflow: 'hidden', opacity: '0', width: '90px', position: 'absolute', zIndex: 1, height: '100px'}}>
                  <GoogleLogin 
                    nonce={sessionHash}
                    key={sessionHash}
                    onSuccess={handleGoogleLogin} shape="circle" width={230} />
                  </div>
                  <span className='gmail-login'>Gmail</span>
              </p>
          </div>
          <div className='dashed-box-apple'>
            <p className='content' 
            style={{position:'relative'}}>
                <span className='apple-login'>
                  {/* @ts-ignore */}
                  <AppleSignin
                    key={sessionHash}
                    authOptions={{
                      clientId: '<replce with com. bundle id>',
                      scope: 'openid email',
                      redirectURI: '<must be a deployed URL>',
                      usePopup: true,
                      nonce: sessionHash
                    }}
                    onError={(error: any) => console.error(error)}
                    onSuccess={handleAppleLogin}
                  />Apple
                </span>
            </p>
            </div>
          </div>
        </>
      : 
        <>
          <div className="login-container">
          <p style={{cursor: 'pointer'}} onClick={() =>signOut()}>sign out</p>
          &nbsp;&nbsp;&nbsp;
          <span >{wallet}</span>
          </div>
        </>
      }
    </>
  )
}

function App() {
  return (
    <LoginScreen/>
  )
}

export default App
```

Then, include a `.env` file in the root of your project, adding it to `.gitignore`, and updating the file with the following values from the Sequence Builder:

```
VITE_PROJECT_ACCESS_KEY=
VITE_WAAS_CONFIG_KEY=
```

<Callout type="warning">
All environment variables must start with `VITE_` to be included in the environment of a vite application
</Callout>

Run your code with the following command in the root folder and give it a try:

```shell
pnpm run dev
```

<Callout type="danger">
In order to allow for a custom sign in page without the Web2 widgets, you'll need to actually hide the standard sign-in buttons from the recommended npm packages. It is best to just copy and paste the whole `App.css` [found here](https://github.com/0xsequence-demos/template-embedded-wallet-web2-auth/blob/master/src/App.css) and include it in your code that has the correct css classes.
</Callout>

## 4. Nonce Generation

Conveniently, Sequence has an available service that enables users to pass in a wallet address to an HTTPS call and produce a nonce that is later retrievable and useable to be verified with.

### GenerateWaaSVerificationURL
* Request: POST https://dev-api.sequence.app/rpc/API/GenerateWaaSVerificationURL
* Content-Type: application/json
* Body (in JSON):
	* `walletAddress` (string) -- the wallet account address
* Response (in JSON):
  * `nonce` (string) -- the generated and Sequence stored nonce for the wallet
  * `verificationURL` -- returns ''

To generate a nonce, use the following code that calls an HTTPS POST with the `walletAddress` passed in the body:

```typescript
const generateNonce = async () => {
    const response = await fetch(`https://dev-api.sequence.app/rpc/API/GenerateWaaSVerificationURL`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({ walletAddress })
    });

    const data = await response.json()
    console.log(data.nonce)
}
...
<button onClick={() => generateNonce()}>
```

You'll need to store the returned nonce response in the frontend to be able to be used in a subsequent request to verify.

## 5. Embedded Wallet Signature

In your frontend code, you'll need to generate a signature, which can be done with the following code that passes in the nonce generated from before and the network name chain handle:

<Callout type="info"> 
The `network` value is the network name in plain text e.g. `mainnet`, `avalanche`, `base`, etc. sourced from the [Sequence Networks Status Page](https://status.sequence.info/) for the network you chose in the Sequence Builder.
</Callout>

```typescript
const authProof = await sequence.sessionAuthProof({ 
    nonce, 
    network
})

const sessionId = authProof.data.sessionId
const signature = authProof.data.signature
```

Where the `sequence` variable is the Embedded Wallet authorized object imported from the `SequenceEmbeddedWallet.ts` file we created prior.

### Produce Verification Link for Wallet Linking app

Once you have the variables required to verify a session, the variables are passed in a URL to redirect your users to the Wallet Linking app, which will be parsed to verify a session so that an EOA can be used to sign in.

```typescript
const externalNonce = nonce
const authProofSignature = signature
const authProofSessionId = sessionId
const chainId = 'arbitrum-nova'
const verificationLink = `${verificationAppUrl}?nonce=${externalNonce}&signature=${authProofSignature}&sessionId=${authProofSessionId}&chainId=${chainId}`
```

And prompt the verification link to the user to redirect the user using something like a `window.open(<URL>)`:

```ts
window.open(verificationLink)
```

## 6. Sequence Kit Sign In Dapp 

In the second dapp, follow the provided walkthrough [here](/solutions/wallets/sequence-kit/getting-started#setting-up-your-dapp) to create an application that enables users to sign in with an Externally-Owned Account (EOA) using Metamask, or, a Coinbase wallet, where the `verificationLink` from [step 5](/solutions/wallets/link-wallets/integration-guide#produce-verification-link-for-wallet-linking-app) links to this 2nd application.

## 7. Embedded Wallet Session Wallet Verification

After creating the URL that is provided to the user and opened in a new tab, the URL in the second application should be parsed, where `verifyEmbeddedWallet` is called in the Wallet Linking app, with the parameters from the URL passed into the `ValidateWaaSVerificationNonce` to see if a `walletAddress` is returned. Subsequently the frontend should be updated to allow for an EOA to be signed into:

### ValidateWaaSVerificationNonce

* Request: POST https://dev-api.sequence.app/rpc/API/ValidateWaaSVerificationNonce
* Content-Type: application/json
* Body (in JSON):
	* `nonce` (string) -- the generated and Sequence stored nonce for the wallet
	* `signature` (string) -- the [ERC6492](https://eips.ethereum.org/EIPS/eip-6492) generated signature
	* `sessionId` (string) -- the `sessionId` for the Embedded Wallet
	* `chainId` (string) -- the `chainId` of the wallet
* Response (in JSON):
  * `walletAddress` (string) -- the validated wallet address

```ts
const verifyEmbeddedWallet = async () => {

    setInProgress(true) // for aesthetics

    const nonce: string | null = urlParams.get("nonce");
    const signature: string | null = urlParams.get("signature");
    const sessionId: string | null = urlParams.get("sessionId");

    console.log("nonce", nonce);
    console.log("signature", signature);
    console.log("chainId", chainId);
    console.log("sessionId", sessionId);

    if (!nonce || !signature || !chainId || !sessionId) {
      console.log("Missing parameters for embedded wallet verification");
      return;
    }

    const apiUrl = 'https://dev-api.sequence.app/rpc/API/ValidateWaaSVerificationNonce';
      
    const headers = {
        'Content-Type': 'application/json'
    };

    const bodyData = {nonce, signature, chainId, sessionId}

    const response = await fetch(apiUrl, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(bodyData)
    })

    const data = await response.json();

    if (data.walletAddress) {
      console.log("Wallet is verified");
      setVerifiedWaaSAddress(data.walletAddress);
    } else {
      console.log("Wallet is not verified");
    }

    setInProgress(false) // for aesthetics
  };

```

Then `verifyEmbeddedWallet` called in a react `useEffect` to verify a session on page load

```ts
useEffect(() => {
  verifyEmbeddedWallet();
}, []);
```

## 8. Query Balances in Singular Interface

Once you have an application with at least 2 signed in wallet addresses, you can use the Sequence Indexer to query multiple balances and aggregate balances based on the `contractAddress` returned from the Indexer. 

This can be accomplished with the following function and example after you've downloaded the Indexer with `pnpm @0xsequence/indexer`:

```typescript
import {SequenceIndexer} from '@0xsequence/indexer'
...
const multiQuery = async (addresses: string[]) => {
    const indexer = new SequenceIndexer('https://<CHAIN_HANDLE>-indexer.sequence.app', 'AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY');

    const balancePromises: any = addresses.map(accountAddress => 
        indexer.getTokenBalances({
            accountAddress: accountAddress,
            includeMetadata: true
        })
    );

    const results:any = await Promise.all(balancePromises);
    
    // Aggregate the balances
    const aggregatedBalances = results.reduce((acc: any, result: any) => {
        result.balances.forEach((balance: any) => {
            const existingBalance = acc.find((b: any) => b.contractAddress === balance.contractAddress);
            if (existingBalance) {
                existingBalance.balance = (Number(existingBalance.balance) + Number(balance.balance)).toString();
            } else {
                // Convert balance to string as the balance is being stored in that format
                balance.balance = balance.balance.toString();
                acc.push(balance);
            }
        });
        return acc;
    }, []);

    return aggregatedBalances;
};

const query = async () => {
    const res = await multiQuery([<wallet_address>, <wallet_address>]);
    console.log('Aggregated token balances:', res);
};
```

### Conclusion

To sum up, we've created an application to authenticate a user, instantiate a non-custodial embedded wallet, and create a cryptographically verifiable URL. This verifiable URL links to another application that validates the previous embedded wallet session and enables a user to connect any external wallet.

While we utilized web technologies for the embedded wallet application, this same logic can be easily extended to Unity, Unreal, or any other framework to create the same verifiable link from nearly any platform.
