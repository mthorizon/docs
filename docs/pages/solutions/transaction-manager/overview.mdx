---
title: Sequence Transaction Manager Implementation Guide
description: The Sequence Transaction Manager simplifies dispatching transactions on Ethereum-compatible networks for games and apps, scaling to millions of users.
---

import {Callout} from 'vocs/components'

# Transaction Manager

The Sequence Transaction Manager leverages the Transaction API for dispatching transactions on Ethereum-compatible networks to service your game or app and scale to millions of users that brings an enormous amount of benefits such as:

- Gas abstraction -- whereby users can pay for network gas in a variety of tokens (ie. USDC, DAI, etc.)
- Sponsored gas -- projects may sponsor the gas of specific contracts to allow free gas for their users
- Batched transactions -- group a bunch of independent transactions and allow them to be mined as a single transaction
- Parallel transactions -- parallelize the dispatch of transactions in some cases
- Fire + forget model -- easily send transactions to the transactions api which will automatically manage nonces, bump gas, and other features which will ensure fast delivery
- Optimal gas pricing for transactions -- will be attempted once and if not included from the mempool within 3 blocks, the transaction will be resubmitted

A Sequence wallet is instantiated with a signer that can be any account such as an EOA. This wallet would then be utilized from your backend where you could could grant certain access control rights on your smart contracts such as minting tokens. Notably, this can be used for any blockchain transaction.

The only difference with respect to deployed EVM contracts: transactions with a Sequence Transaction Manager will have the `msg.sender` as one of the Sequence Relayer addresses, which can be seen in any one of the status pages: for example [here on mainnet](https://mainnet-relayer.sequence.app/status) with the `senders` array.

## NFT Minter Quickstart
One of the most popular implementations is a minting service for creating and minting NFTs to your players from your backend, which massively reduces user friction. Below is a setup guide to run this code locally as a minter service, which can be deployable to any infrastructure callable from your own application. 


::::steps

#### Clone the boilerplate and install:
```shell
npx sequence-cli boilerplates create-server-side-transactions
```

#### Fire a request to mint an NFT to a wallet:

```shell
curl -X POST http://localhost:3001/mint \
-H "Content-Type: application/json" \
-d '{"walletAddress": "0x0365e0BcAd6D799b732ADB9673cB4C43688Bb450"}'
```
::::




## Run on your own local server 

To run your own transaction manager instance and setup, you can run the following command from your terminal to install the Sequence-CLI and create a nodejs app, listening on port `3001`:


Follow the prompts, with the included variables and steps below.
::::steps

#### Sequence Builder Project Management

Create a project using this [walkthrough](/solutions/builder/getting-started).

See [Chain Support](/solutions/technical-references/chain-support) for available networks.

#### Access Key Management

Obtain a Project Access Key using this [walkthrough](/solutions/builder/getting-started#claim-an-api-access-key).

This should be used for `PROJECT_ACCESS_KEY`.

#### Generate Private Key for Transactions API

Generate an Ethereum private key as an Externally Owned Account (EOA) passed into a Relayer Wallet. For demo purposes you can obtain a private key from [here](https://sequence-ethauthproof-viewer.vercel.app/).

#### Deploy an ERC1155 or ERC721 Collectible Contract

Deploy a collectible contract by following this [walkthrough](/solutions/collectibles/contracts/deploy-an-item-collection).

This contract should be used for `contractAddress` in the `cURL` call below, noting to include a `tokenID` if it's an `ERC1155`.

#### Set a `Minter Role` on the Contract

Navigate to the `Contracts` page in the Sequence Builder and under `Write Contract` tab expand the `grantRole` method. Complete with the following details:

* bytes32 role: `0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6`
* address account: `<Generated Wallet Address from Step 4>`

#### Clone and run the boilerplate
This will prompt you to add the requested variables to add them to the environment
```shell
npx sequence-cli boilerplates create-server-side-transactions
```

#### Perform Mint Transaction

Using a command line interface, call using cURL to mint to a wallet address:

```shell
curl -X POST http://localhost:3001/mint \
-H "Content-Type: application/json" \
-d '{"walletAddress": "0x0365e0BcAd6D799b732ADB9673cB4C43688Bb450"}'
```

Input an your desired wallet address you would like to mint to and fire the request!

You should receive a response with a `txHash`:

```shell
{"txHash":"<TX_HASH>"}
```

<Callout type='info'>
The Transaction Manager boilerplate will accept requests from all origins.
</Callout>
::::


You can view the source code of the [boilerplate](https://github.com/0xsequence-demos/server-side-transactions-boilerplate) using the Transactions API by extending the codebase. For example: to incorporate batch transactions, offer ERC20 airdrops, and more.

## Gas Sponsorship
On testnet, we sponsor all the transactions. However, on mainnet - you will want to ensure that you sponsor the transactions in order to ensure that they process correctly. You can take a deeper look at our [Gas Sponsorship](/solutions/builder/gas-tank) solution to do this.